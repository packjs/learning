<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="../libs/babel.min.js"></script>
    <script src="../libs/three.js"></script>
    <script src="../libs/stats.min.js"></script>
    <script src="../controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <div id="Stats-output"></div>
    <div id="WebGL-output"></div>
    <script type="text/babel">
        /**
         * 本文的重点：了解threejs中的几个要素
         */
        // 全局变量
        let renderer;
        let scene;
        let camera;
        let meshs;
        let stats;
        let mixer;

        /**
         * 初始化场景对象
         */
        const initScene = () => {
            // 创建场景
            const scene = new THREE.Scene();
            return scene;
        }

        /**
         * 初始化网格模型
         * Sprite用途
            说到精灵模型对象，这种情况下你肯定关心它的用途，关于用途，
            你可以在三维场景中把精灵模型作为一个模型的标签，标签上可以显示一个写模型的信息，
            你可以通过足够多的精灵模型对象，构建一个粒子系统，来模拟一个下雨、森林、或下雪的场景效果。
         */
        function initMesh() {
            const meshes = [];
            const geometry = new THREE.BoxBufferGeometry(50, 50, 50); //立方体几何对象
            console.log(geometry);
            const box1 = new THREE.BoxBufferGeometry(100, 5, 100); //为变形目标1提供数据
            const box2 = new THREE.BoxBufferGeometry(5, 200, 5); //为变形目标2提供数据
            geometry.morphTargets = [];
            // 设置变形目标的数据
            geometry.morphTargets.push({
                name: 'target1',
                vertices: box1.vertices
            });
            geometry.morphTargets.push({
                name: 'target2',
                vertices: box2.vertices
            });
            const material = new THREE.MeshLambertMaterial({
                morphTargets: true, // 允许变形
                color: 0x0000ff
            });
            const mesh = new THREE.Mesh(geometry, material);    // 网格模型对象
            mesh.morphTargetInfluences = [,];
            //启用变形目标并设置变形目标影响权重，范围一般0~1
            // 设置第一组顶点对几何体形状影响的变形系数
            mesh.morphTargetInfluences[0] = 0.5;
            // 设置第二组顶点对几何体形状影响的变形系数
            mesh.morphTargetInfluences[1] = 1;

            /**
             * 设置关键帧数据
             */
            // 设置变形目标1对应权重随着时间的变化
            var Track1 = new THREE.KeyframeTrack('.morphTargetInfluences[0]', [0, 10, 20], [0, 1, 0]);
            // 设置变形目标2对应权重随着时间的变化
            var Track2 = new THREE.KeyframeTrack('.morphTargetInfluences[1]', [20, 30, 40], [0, 1, 0]);
            // 创建一个剪辑clip对象，命名"default"，持续时间40
            var clip = new THREE.AnimationClip("default", 40, [Track1, Track2]);
            /**
             * 播放编辑好的关键帧数据
             */
            mixer = new THREE.AnimationMixer(mesh); //创建混合器
            var AnimationAction = mixer.clipAction(clip); //返回动画操作对象
            AnimationAction.timeScale = 5; //默认1，可以调节播放速度
            // AnimationAction.loop = THREE.LoopOnce; //不循环播放
            // AnimationAction.clampWhenFinished=true;//暂停在最后一帧播放的状态
            // AnimationAction.play(); //开始播放
            console.log(mesh);
            meshes.push(mesh);


            return meshes;
        }

        /**
         * 初始化光源对象
         */
        function initLight() {
            const lights = [];

            // 新建一个环境光
            const ambient = new THREE.AmbientLight(0x000000);
            lights.push(ambient);

            // 新建一个聚光灯
            const spotLight = new THREE.SpotLight(0xffffff);
            spotLight.position.set(500, 500, 500);
            spotLight.castShadow = true;
            lights.push(spotLight);

            return lights;
        }

        /**
         * 初始化相机对象
         */
        function initCamera() {
            // 创建一个相机
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            // 设置相机在创景中的位置
            camera.position.set(292, 109, 268);
            return camera;
        }

        /**
         * 初始化渲染器对象
         */
        function initRenderer() {
            // 创建一个渲染器，这里使用WebGL渲染器
            const renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            // 设置渲染器的背景色
            renderer.setClearColor(0x000000, 1.0);
            // 设置渲染器区域尺寸
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            return renderer;
        }

        async function init() {
            // 初始化统计
            stats = initStats();

            // 初始化场景
            scene = initScene();

            // 初始化网格模型
            meshs = await initMesh();

            // 将网格模型添加到场景中
            meshs.forEach(mesh => {
                scene.add(mesh);
            });

            // 初始化灯光
            const lights = initLight();

            // 将光源添加到场景中
            lights.forEach(light => {
                scene.add(light);
            });

            // 初始化相机
            camera = initCamera();
            // 设置相机的方向（指向的场景对象）
            camera.lookAt(scene.position);

            // 辅助坐标系  参数250表示坐标系大小，可以根据场景大小去设置
            let axesHelper = new THREE.AxesHelper(250);
            scene.add(axesHelper);

            // 初始化渲染器
            renderer = initRenderer();

            // 将渲染器的dom对象添加到文档中
            document.getElementById("WebGL-output").appendChild(renderer.domElement);

            // 创建鼠标滚动控制对象
            let controls = new THREE.OrbitControls(camera, renderer.domElement);

            // 执行render方法，进行渲染
            render();
        }

        let step = 0;
        // 创建一个时钟对象Clock
        const clock = new THREE.Clock();
        function render() {
            // 统计更新
            stats.update();
            requestAnimationFrame(render);
            // scene.rotation.x += 0.01;
            // scene.rotation.y += 0.01;
            // scene.rotation.z += 0.01;
            renderer.render(scene, camera);
            //clock.getDelta()方法获得两帧的时间间隔
            // 更新混合器相关的时间
            mixer.update(clock.getDelta());
        }

        function initStats() {
            const stats = new Stats();
            stats.setMode(0);   // 0: fps, 2: ms
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';
            document.getElementById("Stats-output").appendChild(stats.domElement);
            return stats;
        }

        // 执行init初始化方法
        window.onload = init;
    </script>
</body>

</html>